"""
漏洞分析器 - 分析扫描结果并识别潜在漏洞
"""

import asyncio
import json
import re
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime
from enum import Enum

from .models import Vulnerability, VulnerabilityType, VulnerabilitySeverity
from core.base import BaseComponent
from core.interfaces import ILogger
from core.exceptions import CybersecurityPlatformError


class VulnerabilityAnalyzer(BaseComponent):
    """漏洞分析器"""
    
    def __init__(self, ai_assistant=None, logger: Optional[ILogger] = None):
        super().__init__(logger)
        self.ai_assistant = ai_assistant
        
        # 漏洞数据库
        self.vulnerability_db = self._load_vulnerability_database()
        
        # 分析规则
        self.analysis_rules = self._load_analysis_rules()
    
    async def _initialize_component(self) -> None:
        """初始化漏洞分析器"""
        if self.logger:
            self.logger.log_info("漏洞分析器初始化完成")
    
    def _load_vulnerability_database(self) -> Dict[str, Any]:
        """加载漏洞数据库"""
        return {
            "ssh": {
                "weak_config": {
                    "cve_ids": ["CVE-2023-1234"],
                    "severity": "medium",
                    "description": "SSH配置存在安全风险",
                    "indicators": ["password_auth_enabled", "root_login_enabled"]
                }
            },
            "http": {
                "directory_traversal": {
                    "cve_ids": ["CVE-2023-5678"],
                    "severity": "high",
                    "description": "目录遍历漏洞",
                    "indicators": ["../", "..\\", "path_traversal"]
                }
            }
        }
    
    def _load_analysis_rules(self) -> List[Dict[str, Any]]:
        """加载分析规则"""
        return [
            {
                "name": "ssh_weak_config",
                "service": "ssh",
                "pattern": r"OpenSSH.*[0-7]\.[0-9]",
                "severity": "medium",
                "description": "SSH版本可能存在已知漏洞"
            },
            {
                "name": "http_server_disclosure",
                "service": "http",
                "pattern": r"Server:\s*(Apache|nginx|IIS).*",
                "severity": "low",
                "description": "HTTP服务器版本信息泄露"
            }
        ]
    
    async def analyze_scan_results(self, scan_results: Dict[str, Any]) -> List[Vulnerability]:
        """分析扫描结果"""
        vulnerabilities = []
        
        try:
            target = scan_results.get("target", "unknown")
            open_ports = scan_results.get("open_ports", [])
            
            for port_info in open_ports:
                port_vulns = await self._analyze_port(target, port_info)
                vulnerabilities.extend(port_vulns)
            
            # 使用AI进行深度分析
            if self.ai_assistant:
                ai_vulns = await self._ai_vulnerability_analysis(scan_results)
                vulnerabilities.extend(ai_vulns)
            
            if self.logger:
                self.logger.log_info(f"漏洞分析完成，发现 {len(vulnerabilities)} 个潜在漏洞")
            
            return vulnerabilities
            
        except Exception as e:
            if self.logger:
                self.logger.log_error("漏洞分析失败", e)
            raise CybersecurityPlatformError(f"漏洞分析失败: {str(e)}")
    
    async def _analyze_port(self, target: str, port_info: Dict[str, Any]) -> List[Vulnerability]:
        """分析单个端口"""
        vulnerabilities = []
        
        port = port_info.get("port")
        service = port_info.get("service", "unknown")
        version = port_info.get("version", "")
        
        # 应用分析规则
        for rule in self.analysis_rules:
            if rule["service"] == service or rule["service"] == "any":
                if re.search(rule["pattern"], version, re.IGNORECASE):
                    vuln = Vulnerability(
                        vulnerability_id=f"VULN_{target}_{port}_{rule['name']}",
                        type=VulnerabilityType.SERVICE_VULNERABILITY,
                        severity=VulnerabilitySeverity(rule["severity"]),
                        target=target,
                        port=port,
                        service=service,
                        description=rule["description"],
                        details={
                            "rule_name": rule["name"],
                            "matched_pattern": rule["pattern"],
                            "service_version": version
                        }
                    )
                    vulnerabilities.append(vuln)
        
        # 检查已知漏洞数据库
        service_vulns = self.vulnerability_db.get(service, {})
        for vuln_name, vuln_info in service_vulns.items():
            if self._check_vulnerability_indicators(port_info, vuln_info):
                vuln = Vulnerability(
                    vulnerability_id=f"VULN_{target}_{port}_{vuln_name}",
                    type=VulnerabilityType.KNOWN_VULNERABILITY,
                    severity=VulnerabilitySeverity(vuln_info["severity"]),
                    target=target,
                    port=port,
                    service=service,
                    description=vuln_info["description"],
                    cve_ids=vuln_info.get("cve_ids", []),
                    details=vuln_info
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _check_vulnerability_indicators(self, port_info: Dict[str, Any], vuln_info: Dict[str, Any]) -> bool:
        """检查漏洞指标"""
        indicators = vuln_info.get("indicators", [])
        
        for indicator in indicators:
            if indicator in str(port_info).lower():
                return True
        
        return False
    
    async def _ai_vulnerability_analysis(self, scan_results: Dict[str, Any]) -> List[Vulnerability]:
        """使用AI进行漏洞分析"""
        try:
            analysis_result = await self.ai_assistant.analyze_threat(scan_results)
            
            ai_vulnerabilities = []
            ai_vulns = analysis_result.get("vulnerabilities", [])
            
            for ai_vuln in ai_vulns:
                vuln = Vulnerability(
                    vulnerability_id=f"AI_VULN_{scan_results.get('target', 'unknown')}_{len(ai_vulnerabilities)}",
                    type=VulnerabilityType.AI_DETECTED,
                    severity=VulnerabilitySeverity(ai_vuln.get("risk", "medium")),
                    target=scan_results.get("target", "unknown"),
                    port=ai_vuln.get("port"),
                    service=ai_vuln.get("service"),
                    description=ai_vuln.get("description", "AI检测到的潜在漏洞"),
                    details={
                        "ai_analysis": ai_vuln,
                        "confidence": ai_vuln.get("confidence", 0.5)
                    }
                )
                ai_vulnerabilities.append(vuln)
            
            return ai_vulnerabilities
            
        except Exception as e:
            if self.logger:
                self.logger.log_error("AI漏洞分析失败", e)
            return []
    
    async def generate_vulnerability_report(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """生成漏洞报告"""
        if not vulnerabilities:
            return {
                "summary": "未发现漏洞",
                "total_vulnerabilities": 0,
                "severity_distribution": {},
                "recommendations": ["继续监控系统安全状态"]
            }
        
        # 统计漏洞分布
        severity_distribution = {}
        for vuln in vulnerabilities:
            severity = vuln.severity.value
            severity_distribution[severity] = severity_distribution.get(severity, 0) + 1
        
        # 生成建议
        recommendations = self._generate_recommendations(vulnerabilities)
        
        return {
            "summary": f"发现 {len(vulnerabilities)} 个潜在漏洞",
            "total_vulnerabilities": len(vulnerabilities),
            "severity_distribution": severity_distribution,
            "vulnerabilities": [vuln.to_dict() for vuln in vulnerabilities],
            "recommendations": recommendations,
            "generated_at": datetime.now().isoformat()
        }
    
    def _generate_recommendations(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """生成修复建议"""
        recommendations = []
        
        # 基于漏洞类型生成建议
        vuln_types = set(vuln.type for vuln in vulnerabilities)
        
        if VulnerabilityType.SERVICE_VULNERABILITY in vuln_types:
            recommendations.append("更新服务到最新版本")
            recommendations.append("检查服务配置安全性")
        
        if VulnerabilityType.KNOWN_VULNERABILITY in vuln_types:
            recommendations.append("应用相关安全补丁")
            recommendations.append("实施额外的安全控制措施")
        
        # 基于严重程度生成建议
        high_severity_vulns = [v for v in vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]
        if high_severity_vulns:
            recommendations.append("优先处理高危漏洞")
            recommendations.append("考虑临时禁用相关服务")
        
        return recommendations or ["定期进行安全评估"]